<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="date" content=''>
<link rel="icon" type="image/png" href="data:image/png;base64,">
<link rel= "stylesheet" href="../../css/style.css">

<html>
  <body>
    <title>  </title>
    <header>
      <h3>
     
        <a href="../../index.html">Home</a>&nbsp
        <a href="../../writing/out/writing.html">Writing</a>&nbsp
        <a href="../../games/out/games.html">Games</a>&nbsp
        <a href="../../music/out/music.html">Music</a>&nbsp
        <a href="dev.html">Dev</a>&nbsp
      
      </h3> 
  
    </header>
    
    <h1 id="trees">Trees</h1>
    <p>Data structure that forms some kind of meaningful hierarchy on a set of Data.</p>
    <p>Start off with a node that is called the root. Nodes in trees are connected by edges. (C++: abstract, represented by pointers that connect to other nodes). (Could also be represented by array index)</p>
    <p>The nodes of a linked list are kinda like a tree, each connected by a one-directional edge that is represented by the next pointer. The pointers have no special meaning other than acting as links. In trees, the links or edges signify some relationship.</p>
    <p>A tree itself is a type of graph.</p>
    <h2 id="traversal">Traversal</h2>
    <h3 id="bfs-or-level-order-traversal">BFS or Level Order Traversal</h3>
    <p>More in graphs ### Depth First Searches -- preorder: node, left, right - -- postorder: left, right, node - used to delete a tree e.g. because child nodes visited first -- inorder: left, node, right</p>
    <h2 id="general-trees">General Trees</h2>
    <ul>
    <li>Root, children, siblings, Parents</li>
    <li>Not so fast for searches etc</li>
    </ul>
    <h2 id="binary-trees">Binary Trees</h2>
    <ul>
    <li>Two child nodes max, left and right</li>
    <li>fast insertions, deletions and searching</li>
    <li>keys play important role:
    <ul>
    <li>if key of node is higher than root, new node is placed on right, otherwise as left child</li>
    <li>if a child already exists, new node is allocated to right or left of child</li>
    </ul></li>
    <li>the larger the tree, n, the more efficient some algorithsm:
    <ul>
    <li>in ordered array of 1000k items, would need on average 500k comparisons to find position of object. In binary Tree, would need max 20 comparisons.</li>
    <li>C = log(N-1)
    <ul>
    <li>depends on if tree is balanced or not (has on average equal number of left and right child nodes)</li>
    <li>worst case unbalanced is when nodes inserted in ascending or descending order, which results in a completely one sided tree, or a list.</li>
    </ul></li>
    </ul></li>
    <li>the order in which nodes are inserted decides if a tree is balanced or unbalanced and how unbalanced</li>
    </ul>
    <h2 id="kd-trees">kd-trees</h2>
    <ul>
    <li>k dimensional tree, keys have multiple (k) dimensions</li>
    <li>range searches, nearest neighbor searches, space partitioning etc</li>
    <li>kd tree with one dimension == binary tree</li>
    </ul>
    <h2 id="b-trees">B-trees</h2>
    <ul>
    <li>balanced tree, multiple child nodes can be attached to one node according to predefined range.</li>
    <li>if node violates range, tree is reordered by joining nodes together or splitting them.</li>
    <li>waste maybe more space but do not need to be rebalanced as often</li>
    <li>kept balanced by keeping all lead nodes on same depth</li>
    <li>more complicated to implement, used in databases etc</li>
    </ul>
    <h3 id="trees-1">2-3 trees</h3>
    <ul>
    <li>b-trees of order 3 (can have upto 3 child nodes for each node)</li>
    <li>a node with data item can have two children, a node with two data items can have 3 children.</li>
    <li>self balancing tree, ordered tree</li>
    </ul>
    <h3 id="trees-2">2-3-4 trees</h3>
    <ul>
    <li>order of 4 (4 child nodes up to)</li>
    <li>harder to implement than black-red tree but considered equivilant, isomorphic.</li>
    </ul>
    <h2 id="bsp-tree">BSP tree</h2>
    <h2 id="avl-trees">AVL trees</h2>
    <ul>
    <li>self balancing binary search tree (2 child nodes for every node)</li>
    <li>heights? of child nodes differ most by one
    <ul>
    <li>height value or balance factor : value of adding up all child node keys on both sides (left and right). Difference between these two totals should be 1,0,-1, or else tree is not balanced.</li>
    <li>balance factor of a node is the height of the right child minus the hight of the left child of any given node. If between -1 and 1, node is balanced.</li>
    </ul></li>
    <li>tree rotations used to keep tree balanced when isnerting deleting nodes</li>
    </ul>
    <h2 id="red-black-trees">Red-black trees</h2>
    <ul>
    <li>balanced binary trees.</li>
    <li>more complicated than a binary tree but easier than most b-trees</li>
    <li>insertion and deletions are different, top down or bottom up, alter structure of tree to keep it balanced.</li>
    </ul>
    <h2 id="heaps">Heaps</h2>
    <ul>
    <li>weakly ordered binary tree</li>
    <li>completely silled from left to right without gaps</li>
    <li><p>every node in heap is larger than or euqual to its child nodes</p></li>
    <li><p>purpose usually to allow fast removal from top of heap (getting the max value repeatedly)</p></li>
    <li>keeps node with largest key as root key, on top of tree (depending on order condition)</li>
    <li>all nodes within are not necessarily in order, unlike binary trees.
    <ul>
    <li>just that child nodes keys are lesser than root node key.</li>
    </ul></li>
    <li>STL priority queue uses heap as underlying data structure.</li>
    <li>cannot use binary search algorithm as for other trees because weakly ordered.</li>
    <li><p>Heaps themselves often implemented as arrays with non linear expansion size when memory is not critical.</p></li>
    <li><p>PriorityQueues by default are similar/maintain structure of Max Heap. -- PriorityQueue implemented using heap</p></li>
    </ul>

  </body>
</html>
